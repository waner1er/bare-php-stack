{
  "version": 3,
  "sources": ["../../tinymce/plugins/lists/plugin.js", "../../tinymce/plugins/lists/index.js"],
  "sourcesContent": ["/**\n * TinyMCE version 8.3.2 (2026-01-14)\n */\n\n(function () {\n    'use strict';\n\n    var global = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const get = (editor) => ({\n        backspaceDelete: (isForward) => {\n            editor.execCommand('mceListBackspaceDelete', false, isForward);\n        }\n    });\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isFunction = isSimpleType('function');\n\n    const constant = (value) => {\n        return () => {\n            return value;\n        };\n    };\n    const tripleEquals = (a, b) => {\n        return a === b;\n    };\n    const never = constant(false);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        tag;\n        value;\n        // Sneaky optimisation: every instance of Optional.none is identical, so just\n        // reuse the same object\n        static singletonNone = new Optional(false);\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message ?? 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n\n    const nativeSlice = Array.prototype.slice;\n    const exists = (xs, pred) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const map = (xs, f) => {\n        // pre-allocating array size when it's guaranteed to be known\n        // http://jsperf.com/push-allocated-vs-dynamic/22\n        const len = xs.length;\n        const r = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const x = xs[i];\n            r[i] = f(x, i);\n        }\n        return r;\n    };\n    // Unwound implementing other functions in terms of each.\n    // The code size is roughly the same, and it should allow for better optimisation.\n    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {\n    const each = (xs, f) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const foldl = (xs, f, acc) => {\n        each(xs, (x, i) => {\n            acc = f(acc, x, i);\n        });\n        return acc;\n    };\n    const findUntil = (xs, pred, until) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return Optional.some(x);\n            }\n            else if (until(x, i)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n    const find = (xs, pred) => {\n        return findUntil(xs, pred, never);\n    };\n    const reverse = (xs) => {\n        const r = nativeSlice.call(xs, 0);\n        r.reverse();\n        return r;\n    };\n    isFunction(Array.from) ? Array.from : (x) => nativeSlice.call(x);\n\n    /**\n     * **Is** the value stored inside this Optional object equal to `rhs`?\n     */\n    const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left) => comparator(left, rhs));\n\n    const blank = (r) => (s) => s.replace(r, '');\n    /** removes all leading and trailing spaces */\n    const trim = blank(/^\\s+|\\s+$/g);\n    const isNotEmpty = (s) => s.length > 0;\n    const isEmpty = (s) => !isNotEmpty(s);\n\n    // Example: 'AB' -> 28\n    const parseAlphabeticBase26 = (str) => {\n        const chars = reverse(trim(str).split(''));\n        const values = map(chars, (char, i) => {\n            const charValue = char.toUpperCase().charCodeAt(0) - 'A'.charCodeAt(0) + 1;\n            return Math.pow(26, i) * charValue;\n        });\n        return foldl(values, (sum, v) => sum + v, 0);\n    };\n    // Example: 28 -> 'AB'\n    const composeAlphabeticBase26 = (value) => {\n        value--;\n        if (value < 0) {\n            return '';\n        }\n        else {\n            const remainder = value % 26;\n            const quotient = Math.floor(value / 26);\n            const rest = composeAlphabeticBase26(quotient);\n            const char = String.fromCharCode('A'.charCodeAt(0) + remainder);\n            return rest + char;\n        }\n    };\n    const isUppercase = (str) => /^[A-Z]+$/.test(str);\n    const isLowercase = (str) => /^[a-z]+$/.test(str);\n    const isNumeric = (str) => /^[0-9]+$/.test(str);\n    const deduceListType = (start) => {\n        if (isNumeric(start)) {\n            return 2 /* ListType.Numeric */;\n        }\n        else if (isUppercase(start)) {\n            return 0 /* ListType.UpperAlpha */;\n        }\n        else if (isLowercase(start)) {\n            return 1 /* ListType.LowerAlpha */;\n        }\n        else if (isEmpty(start)) {\n            return 3 /* ListType.None */;\n        }\n        else {\n            return 4 /* ListType.Unknown */;\n        }\n    };\n    const parseStartValue = (start) => {\n        switch (deduceListType(start)) {\n            case 2 /* ListType.Numeric */:\n                return Optional.some({\n                    listStyleType: Optional.none(),\n                    start\n                });\n            case 0 /* ListType.UpperAlpha */:\n                return Optional.some({\n                    listStyleType: Optional.some('upper-alpha'),\n                    start: parseAlphabeticBase26(start).toString()\n                });\n            case 1 /* ListType.LowerAlpha */:\n                return Optional.some({\n                    listStyleType: Optional.some('lower-alpha'),\n                    start: parseAlphabeticBase26(start).toString()\n                });\n            case 3 /* ListType.None */:\n                return Optional.some({\n                    listStyleType: Optional.none(),\n                    start: ''\n                });\n            case 4 /* ListType.Unknown */:\n                return Optional.none();\n        }\n    };\n    const parseDetail = (detail) => {\n        const start = parseInt(detail.start, 10);\n        if (is(detail.listStyleType, 'upper-alpha')) {\n            return composeAlphabeticBase26(start);\n        }\n        else if (is(detail.listStyleType, 'lower-alpha')) {\n            return composeAlphabeticBase26(start).toLowerCase();\n        }\n        else {\n            return detail.start;\n        }\n    };\n\n    const option = (name) => (editor) => editor.options.get(name);\n    const getForcedRootBlock = option('forced_root_block');\n\n    const isCustomList = (list) => /\\btox\\-/.test(list.className);\n    const matchNodeNames = (regex) => (node) => isNonNullable(node) && regex.test(node.nodeName);\n    const matchNodeName = (name) => (node) => isNonNullable(node) && node.nodeName.toLowerCase() === name;\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const isListItemNode = matchNodeNames(/^(LI|DT|DD)$/);\n    const inList = (parents, listName) => findUntil(parents, isListNode, isTableCellNode)\n        .exists((list) => list.nodeName === listName && !isCustomList(list));\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n        const initialNode = editor.selection.getNode();\n        // Set the initial state\n        nodeChangeHandler({\n            parents: editor.dom.getParents(initialNode),\n            element: initialNode\n        });\n        editor.on('NodeChange', nodeChangeHandler);\n        return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);\n    const isWithinNonEditableList = (editor, element) => {\n        const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n        return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();\n    };\n    const isOlNode = matchNodeName('ol');\n    const listNames = ['OL', 'UL', 'DL'];\n    const listSelector = listNames.join(',');\n    const getParentList = (editor, node) => {\n        const selectionStart = node || editor.selection.getStart(true);\n        return editor.dom.getParent(selectionStart, listSelector, getClosestListHost(editor, selectionStart));\n    };\n    const getClosestListHost = (editor, elm) => {\n        const parentBlocks = editor.dom.getParents(elm, editor.dom.isBlock);\n        const isNotForcedRootBlock = (elm) => elm.nodeName.toLowerCase() !== getForcedRootBlock(editor);\n        const parentBlock = find(parentBlocks, (elm) => isNotForcedRootBlock(elm) && isListHost(editor.schema, elm));\n        return parentBlock.getOr(editor.getBody());\n    };\n    const isListHost = (schema, node) => !isListNode(node) && !isListItemNode(node) && exists(listNames, (listName) => schema.isValidChild(node.nodeName, listName));\n\n    const open = (editor) => {\n        // Find the current list and skip opening if the selection isn't in an ordered list\n        const currentList = getParentList(editor);\n        if (!isOlNode(currentList) || isWithinNonEditableList(editor, currentList)) {\n            return;\n        }\n        editor.windowManager.open({\n            title: 'List Properties',\n            body: {\n                type: 'panel',\n                items: [\n                    {\n                        type: 'input',\n                        name: 'start',\n                        label: 'Start list at number',\n                        inputMode: 'numeric'\n                    }\n                ]\n            },\n            initialData: {\n                start: parseDetail({\n                    start: editor.dom.getAttrib(currentList, 'start', '1'),\n                    listStyleType: Optional.from(editor.dom.getStyle(currentList, 'list-style-type'))\n                })\n            },\n            buttons: [\n                {\n                    type: 'cancel',\n                    name: 'cancel',\n                    text: 'Cancel'\n                },\n                {\n                    type: 'submit',\n                    name: 'save',\n                    text: 'Save',\n                    primary: true\n                }\n            ],\n            onSubmit: (api) => {\n                const data = api.getData();\n                parseStartValue(data.start).each((detail) => {\n                    editor.execCommand('mceListUpdate', false, {\n                        attrs: {\n                            start: detail.start === '1' ? '' : detail.start\n                        },\n                        styles: {\n                            'list-style-type': detail.listStyleType.getOr('')\n                        }\n                    });\n                });\n                api.close();\n            }\n        });\n    };\n\n    const register$2 = (editor) => {\n        editor.addCommand('mceListProps', () => {\n            open(editor);\n        });\n    };\n\n    const setupToggleButtonHandler = (editor, listName) => (api) => {\n        const toggleButtonHandler = (e) => {\n            api.setActive(inList(e.parents, listName));\n            api.setEnabled(!isWithinNonEditableList(editor, e.element) && editor.selection.isEditable());\n        };\n        api.setEnabled(editor.selection.isEditable());\n        return setNodeChangeHandler(editor, toggleButtonHandler);\n    };\n    const register$1 = (editor) => {\n        const exec = (command) => () => editor.execCommand(command);\n        if (!editor.hasPlugin('advlist')) {\n            editor.ui.registry.addToggleButton('numlist', {\n                icon: 'ordered-list',\n                active: false,\n                tooltip: 'Numbered list',\n                onAction: exec('InsertOrderedList'),\n                onSetup: setupToggleButtonHandler(editor, 'OL')\n            });\n            editor.ui.registry.addToggleButton('bullist', {\n                icon: 'unordered-list',\n                active: false,\n                tooltip: 'Bullet list',\n                onAction: exec('InsertUnorderedList'),\n                onSetup: setupToggleButtonHandler(editor, 'UL')\n            });\n        }\n    };\n\n    const setupMenuButtonHandler = (editor, listName) => (api) => {\n        const menuButtonHandler = (e) => api.setEnabled(inList(e.parents, listName) && !isWithinNonEditableList(editor, e.element));\n        return setNodeChangeHandler(editor, menuButtonHandler);\n    };\n    const register = (editor) => {\n        const listProperties = {\n            text: 'List properties...',\n            icon: 'ordered-list',\n            onAction: () => editor.execCommand('mceListProps'),\n            onSetup: setupMenuButtonHandler(editor, 'OL')\n        };\n        editor.ui.registry.addMenuItem('listprops', listProperties);\n        editor.ui.registry.addContextMenu('lists', {\n            update: (node) => {\n                const parentList = getParentList(editor, node);\n                return isOlNode(parentList) ? ['listprops'] : [];\n            }\n        });\n    };\n\n    var Plugin = () => {\n        global.add('lists', (editor) => {\n            register$2(editor);\n            register$1(editor);\n            register(editor);\n            return get(editor);\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n", "// Exports the \"lists\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/lists')\n//   ES2015:\n//     import 'tinymce/plugins/lists'\nrequire('./plugin.js');"],
  "mappings": "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",
  "names": ["elm"]
}
